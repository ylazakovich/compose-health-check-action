name: "Compose DevOps Healthcheck"
description: "Runs docker compose and validates container health"
author: "Yaraslau Lazakovich"

branding:
  icon: "check-circle"
  color: "blue"

inputs:
  compose-files:
    description: "List of docker-compose files (one per line)"
    required: true
    default: |
      docker-compose.yml
  services:
    description: "List of services to check (space-separated). Defaults to all services when omitted; ignored when docker-command is set."
    required: false
    default: ""
  timeout:
    description: "Healthcheck timeout per service in seconds"
    required: false
    default: "120"
  additional-compose-args:
    description: "Additional args for docker compose (e.g. --quiet-pull or --build)"
    required: false
    default: ""
  docker-command:
    description: "Full docker compose command to execute instead of compose-files/services (e.g. docker compose -f docker-compose.yml up -d web)"
    required: false
    default: ""
  report-format:
    description: "Healthcheck report format: text | json | both"
    required: false
    default: "text"

outputs:
  summary_b64:
    description: "Base64-encoded human-readable output of healthcheck"
    value: ${{ steps.run_healthcheck.outputs.summary_b64 }}
  report_json_b64:
    description: "Base64-encoded machine-readable JSON healthcheck report (when enabled)"
    value: ${{ steps.run_healthcheck.outputs.report_json_b64 }}

runs:
  using: "composite"
  steps:
    - id: run_healthcheck
      name: Run docker compose with health check
      shell: bash
      env:
        DOCKER_HEALTH_TIMEOUT: ${{ inputs.timeout }}
        DOCKER_SERVICES_LIST: ${{ inputs.services }}
        DOCKER_HEALTH_REPORT_FORMAT: ${{ inputs.report-format }}
      run: |
        set -euo pipefail

        SCRIPT_DIR="${GITHUB_ACTION_PATH}"

        compose_files_input="${{ inputs.compose-files }}"
        additional_args_input="${{ inputs.additional-compose-args }}"
        services_input="${{ inputs.services }}"
        report_format_input="${{ inputs.report-format }}"
        docker_command_input="${{ inputs.docker-command }}"

        if [[ -n "$docker_command_input" ]]; then
          unset DOCKER_SERVICES_LIST
        fi

        parse_docker_command() {
          if ! command -v python3 >/dev/null 2>&1; then
            echo "python3 is required to parse docker-command safely." >&2
            exit 1
          fi
          python3 - <<'PY' "$docker_command_input"
import shlex
import sys

cmd = sys.argv[1]
parts = shlex.split(cmd)
sys.stdout.write("\0".join(parts) + "\0")
PY
        }

        if [[ -n "$docker_command_input" ]]; then
          mapfile -d '' -t CMD < <(parse_docker_command)
          if ((${#CMD[@]} < 2)) || [[ "${CMD[0]}" != "docker" || "${CMD[1]}" != "compose" ]]; then
            echo "docker-command must start with 'docker compose'." >&2
            exit 1
          fi
        else
          CMD=(docker compose)

          while IFS= read -r file; do
            if [[ -n "$file" ]]; then
              CMD+=(-f "$file")
            fi
          done <<<"$compose_files_input"

        CMD+=(up -d)

        if [[ -n "$additional_args_input" ]]; then
          read -r -a extra_args <<<"$additional_args_input"
          CMD+=("${extra_args[@]}")
        fi

        if [[ -n "$services_input" ]]; then
          read -r -a svc_arr <<<"$services_input"
          CMD+=("${svc_arr[@]}")
        fi
        fi

        TMP_OUT="$(mktemp)"
        JSON_TMP="$(mktemp)"

        # Tell the healthcheck script where to write JSON (if report-format is json/both).
        export DOCKER_HEALTH_REPORT_JSON_FILE="$JSON_TMP"
        export DOCKER_HEALTH_REPORT_FORMAT="$report_format_input"

        set +e
        bash "${SCRIPT_DIR}/entrypoint.sh" "${CMD[@]}" 2>&1 | tee "$TMP_OUT"
        rc=${PIPESTATUS[0]}
        set -e

        OUTPUT_B64="$(base64 <"$TMP_OUT" | tr -d '\n')"
        echo "summary_b64=$OUTPUT_B64" >>"$GITHUB_OUTPUT"

        # JSON output is optional; only publish if present and non-empty
        if [[ -s "$JSON_TMP" ]]; then
          JSON_B64="$(base64 <"$JSON_TMP" | tr -d '\n')"
          echo "report_json_b64=$JSON_B64" >>"$GITHUB_OUTPUT"
        else
          echo "report_json_b64=" >>"$GITHUB_OUTPUT"
        fi

        rm -f "$TMP_OUT" "$JSON_TMP"
        exit "$rc"
